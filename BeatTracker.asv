classdef BeatTracker < handle
    properties (SetAccess = private)
        onsets      % List of sequential onsets in ms
        H = {}      % Cell array of current hypotheses
        out
    end

    properties (SetAccess = immutable)
        window
        mult
        decay
        delta
    end

    methods
        % Constructor
        % 
        % Inputs:
        %   sampOnsets: List of sequential onsets in ms
        %   window: Size of sliding window for tracking in ms
        %   mult: Correction multiplier (see Correction.m)
        %   decay: Correction decay (see Correction.m)
        %   delta: Similarity tolerance threshold in ms (see Hypothesis.m)
        function obj = BeatTracker(onsets,window,mult,decay,delta)
            obj.onsets = onsets;
            obj.window = window;
            obj.mult = mult;
            obj.decay = decay;
            obj.delta = delta;

            obj.out = Inf(length(onsets),6);
            obj.out(:,1) = obj.onsets';
        end

        % Main beat tracking function, based on onsets fed into program.
        function track(self)
            self.H = {};
            for on = 2:length(self.onsets)
                t = self.onsets(on);

                % Generate new hypothesis from current and previous onsets
                period = t-self.onsets(on-1);
                phase = mod(t,period);
                self.H{end+1} = Hypothesis(period,phase,on-1,on);

                % Calculate start time of window
                s = t-self.window; 
                
                % Skip if not enough time to window
                if s < 0
                    continue
                end

                % Get windowed onsets
                onsetWind = Util.getWindow(self.onsets,s,t);

                for h = 1:length(self.H)
                    hyp = self.H{h};
                    % Get windowed projection
                    proj = hyp.project(t,self.window);
    
                    % Update hypothesis:
                    %   1. Calculate correction in given window
                    %   2. Calculate score
                    %   3. Update hypothesis and store changes
                    hyp.update(proj,onsetWind,self.mult,self.decay)

                end
    
                % Iterate through every unique pair hyp1, hyp2 in H to delete 
                % ones that are too similar to each other.
                if length(self.H) < 2
                    continue
                end
                hypIdx = nchoosek(1:length(self.H),2);
                delete = [];
                for i = 1:height(hypIdx)
                    hyp1 = self.H{hypIdx(i,1)};
                    hyp2 = self.H{hypIdx(i,2)};
                    % If h1, h2 too similar, remove the most recent one (TODO:
                    % see if lower scoring is better)
                    if Hypothesis.similar(hyp1,hyp2,self.delta)
                        % Cell array deletion
                        delete(end+1) = hypIdx(i,2);
                    end
                end
                self.H(delete) = [];
            end
        end

        

        % Finds optimal beat at different times given score
        function findOptimum(self)
            % Rows: Onsets
            % Columns: Period, Phase, Score
            for h = 1:length(self.H)
                hyp = self.H{h};
                for on = hyp.startOn:length(self.onsets)
                    t = self.onsets(on);
                    s = t-self.window; 
                    
                    % Skip if not enough time to window
                    if s < 0
                        continue
                    end
    
                    % Get windowed onsets
                    proj = hyp.project(t,self.window);
                    onsetWind = Util.getWindow(self.onsets,s,t);
   
                    matches = Util.closestPairs(proj,onsetWind);
                    score = Correction.calcScore(hyp,proj,onsetWind,matches);
                    if hyp.score < self.out(on,4)
                        self.out(on,2:6) = [hyp.startOn hyp.endOn hyp.period hyp.phase hyp.score];
                    end
                end
            end
        end
    end
end